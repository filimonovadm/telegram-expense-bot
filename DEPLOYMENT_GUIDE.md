# Руководство по миграции и развертыванию Telegram-бота на Firebase

Это руководство описывает процесс переноса Telegram-бота, написанного на Python, с локального хостинга (режим `polling`, база данных SQLite) на бессерверную архитектуру (serverless) в облаке Google Cloud с использованием Firebase.

**Итоговая архитектура:**
- **Хостинг:** Firebase Cloud Functions (2-го поколения).
- **База данных:** Firestore.
- **Метод обновлений:** Веб-хуки (Webhooks).

---

## Часть 1: Миграция базы данных с SQLite на Firestore

На этом этапе мы заменяем локальную базу данных на облачную NoSQL базу данных Firestore.

### 1.1. Настройка проекта Firebase

1.  Перейдите в [консоль Firebase](https://console.firebase.google.com/) и создайте новый проект.
2.  В меню проекта выберите "Сборка" -> "Firestore Database".
3.  Создайте базу данных. Для начала можно выбрать тестовый режим (`test mode`).

### 1.2. Получение ключа доступа

1.  В настройках проекта (значок ⚙️) перейдите на вкладку "Сервисные аккаунты".
2.  Нажмите "Создание нового закрытого ключа".
3.  Сохраните сгенерированный JSON-файл. Переименуйте его в `firebase_credentials.json` и положите в корень проекта. **Этот файл содержит секретные данные, его нельзя публиковать.**

### 1.3. Обновление зависимостей Python

В ваш файл `requirements.txt` необходимо добавить библиотеку для работы с Firebase:

```
firebase-admin
```

### 1.4. Рефакторинг кода для работы с Firestore

Вам нужно изменить код так, чтобы вместо `sqlite3` он использовал `firebase-admin`.

1.  **Файл конфигурации (`config.py`):** Вместо пути к файлу `.db` укажите путь к файлу `firebase_credentials.json`.
2.  **Модуль базы данных (`database.py`):**
    - Напишите функцию `initialize_firebase()` для инициализации соединения с Firestore с помощью вашего ключа.
    - Перепишите все функции для работы с базой данных (`add_user`, `add_expense` и т.д.), используя методы клиента Firestore (например, `db.collection('users').document('...').set(...)`).
3.  **Основной файл (`main.py`):** При старте бота вызовите `initialize_firebase()`.

### 1.5. (Опционально) Миграция старых данных

Чтобы не потерять данные из старой базы SQLite, можно написать отдельный скрипт (`migrate_db.py`), который:
1.  Инициализирует соединение с Firebase.
2.  Подключается к старому файлу `bot_data.db`.
3.  Читает данные из каждой таблицы SQLite.
4.  Записывает эти данные в Firestore, используя новые функции из `database.py`.

---

## Часть 2: Рефакторинг бота с Polling на Webhook

На этом этапе мы меняем архитектуру бота, чтобы он не опрашивал сервер Telegram, а принимал входящие запросы.

### 2.1. Настройка Firebase CLI

1.  Установите инструмент командной строки Firebase: `npm install -g firebase-tools`.
2.  Авторизуйтесь: `firebase login`.
3.  В корне проекта инициализируйте Cloud Functions: `firebase init functions`.
    - Выберите существующий проект.
    - Выберите язык **Python**.
    - Согласитесь на создание виртуального окружения и установку зависимостей.

Эта команда создаст в проекте папку `functions`.

### 2.2. Реструктуризация проекта

Облачная функция должна быть самодостаточной. Весь ее код и зависимости должны находиться внутри папки `functions`.

1.  Переместите папку с логикой вашего бота (в нашем случае `bot`) внутрь папки `functions`.
2.  Переместите ваш ключ `firebase_credentials.json` также внутрь `functions`.

### 2.3. Зависимости для облачной функции

В файле `functions/requirements.txt` укажите все необходимые пакеты. В нашем случае это:

```txt
firebase-functions
firebase-admin
python-telegram-bot==13.15  # Версия может быть важна
Flask  # Для создания веб-сервера
urllib3<2.0  # Важно для совместимости
python-dotenv # Для локального анализа кода
```

### 2.4. Рефакторинг основного файла (`functions/main.py`)

Это ключевой этап. `main.py` больше не запускает бесконечный процесс, а описывает функцию, которая реагирует на HTTP-запрос.

1.  Импортируйте `https_fn` из `firebase_functions` и `flask`.
2.  Инициализируйте `bot` и `dispatcher` из `telegram.ext` глобально.
3.  Зарегистрируйте все ваши обработчики команд в `dispatcher`.
4.  Создайте экземпляр `flask.Flask`.
5.  Создайте маршрут (route), например `/webhook`, который принимает `POST` запросы. Внутри этой функции:
    - Получите JSON из тела запроса.
    - Преобразуйте его в объект `telegram.Update`.
    - Передайте объект в `dispatcher.process_update(update)`.
6.  Создайте основную облачную функцию с помощью декоратора `@https-fn.on_request()` и передайте ей ваше Flask-приложение.

---

## Часть 3: Развертывание и решение проблем

### 3.1. Устранение ошибок зависимостей

При развертывании вы можете столкнуться с ошибками `ModuleNotFoundError`.

- **Проблема `imghdr`:** Старые версии `python-telegram-bot` несовместимы с Python 3.13+. Решение — указать Firebase использовать более старую версию Python. Откройте файл `firebase.json` и пропишите версию рантайма:
  ```json
  "runtime": "python312"
  ```
- **Проблема `urllib3`:** Конфликт версий `urllib3` между `telegram-bot` и `firebase-admin`. Решение — жестко закрепить версию в `functions/requirements.txt`:
  ```
urllib3<2.0
  ```
- **Проблема `dotenv`:** Инструмент `firebase deploy` выполняет код перед загрузкой, поэтому ему нужны все импортируемые зависимости, даже те, что не используются в облаке. Убедитесь, что `python-dotenv` есть в `functions/requirements.txt`.

После каждого изменения `requirements.txt` или `firebase.json` **важно пересоздавать и переустанавливать виртуальное окружение** в папке `functions`:

```bash
cd functions
rm -rf venv
python3.12 -m venv venv
venv/bin/pip install -r requirements.txt
cd ..
```

### 3.2. Настройка переменных окружения

Секретные данные (токены, ID чатов) не загружаются из `.env` файла. Их нужно задать в облаке.

1.  Создайте файл `functions/.env` с вашими секретами.
2.  Добавьте `functions/.env` в `.gitignore`.
3.  Выполните развертывание. Firebase CLI автоматически подхватит этот файл и установит переменные для функции.

### 3.3. Развертывание

Для развертывания функции выполните из корня проекта:

```bash
firebase deploy --only functions
```

После успешного завершения скопируйте **URL функции** из вывода команды.

---

## Часть 4: Финальная настройка

### 4.1. Предоставление публичного доступа

По умолчанию функция приватна. Чтобы Telegram мог ее вызывать, нужно сделать ее публичной.

1.  Выполните команду `gcloud`, подставив свои данные:
    ```bash
    gcloud run services add-iam-policy-binding <function-name> --member=allUsers --role=roles/run.invoker --region=<region> --project=<project-id>
    ```
    В нашем случае это было:
    `gcloud run services add-iam-policy-binding turkeybot --member=allUsers --role=roles/run.invoker --region=us-central1 --project=stasbaikalbot`

### 4.2. Установка веб-хука

Последний шаг — сказать Telegram, куда отправлять обновления. Выполните `curl` запрос, подставив ваш токен и URL функции:

```bash
curl "https://api.telegram.org/bot<YOUR_BOT_TOKEN>/setWebhook?url=<YOUR_FUNCTION_URL>/webhook"
```

Если вы получили `{"ok":true...}`, ваш бот полностью готов и работает в облаке.

---

## Часть 5: Новый рабочий процесс

Вам больше не нужно заходить на сервер. Чтобы обновить код бота:
1.  Внесите изменения локально.
2.  Выполните команду `firebase deploy --only functions`.

Firebase автоматически обновит код вашей функции в облаке.
